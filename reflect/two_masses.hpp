#pragma once

//=============================================================================
// TWO MASSES WITH SPRING - Reflection-Based API Prototype
//=============================================================================
//
// This file demonstrates what the reflection-based SOPOT API would look like.
// Compare with physics/coupled_oscillator/ to see the difference.
//
// CURRENT SOPOT (physics/coupled_oscillator/):
//   - User must understand templates: TypedComponent<2, T>
//   - User must create tag namespaces: mass1::Position, mass1::Velocity
//   - User must write compute() methods with registry access
//   - User must wire everything with TypedODESystem
//   - ~250 lines across multiple files
//
// REFLECTION-BASED SOPOT (this file):
//   - User writes plain struct with plain members
//   - User writes plain functions with descriptive names
//   - Framework infers wiring from function signatures
//   - ~50 lines total
//
//=============================================================================

#include <vector>
#include <array>
#include <cmath>
#include <iostream>
#include <iomanip>

namespace sopot::reflect {

//=============================================================================
// WHAT THE USER WRITES - Plain struct, plain functions
//=============================================================================

struct TwoMassSpring {
    //=========================================================================
    // STATE VARIABLES - Just declare them as members
    // Framework detects: these have corresponding _dot() methods = state vars
    //=========================================================================

    double x1 = 0.0;    // Position of mass 1 [m]
    double v1 = 0.0;    // Velocity of mass 1 [m/s]
    double x2 = 1.0;    // Position of mass 2 [m]
    double v2 = 0.0;    // Velocity of mass 2 [m/s]

    //=========================================================================
    // PARAMETERS - Members without _dot() methods = parameters
    //=========================================================================

    double m1 = 1.0;    // Mass 1 [kg]
    double m2 = 1.0;    // Mass 2 [kg]
    double k = 10.0;    // Spring stiffness [N/m]
    double c = 0.1;     // Damping coefficient [NÂ·s/m]
    double L0 = 1.0;    // Rest length [m]

    //=========================================================================
    // COMPUTED QUANTITIES - Pure functions, framework infers dependencies
    //=========================================================================

    // Spring extension (computed from positions)
    double extension() const {
        return x2 - x1 - L0;
    }

    // Spring force magnitude
    double spring_force() const {
        return -k * extension();
    }

    // Damping force magnitude
    double damping_force() const {
        return -c * (v2 - v1);
    }

    // Total internal force
    double internal_force() const {
        return spring_force() + damping_force();
    }

    // Force on mass 1
    double F1() const {
        return -internal_force();  // Pulls mass 1 toward mass 2
    }

    // Force on mass 2
    double F2() const {
        return internal_force();   // Pulls mass 2 toward mass 1
    }

    //=========================================================================
    // DERIVATIVES - Functions ending in _dot define the ODE
    // Framework sees: x1_dot, v1_dot, x2_dot, v2_dot
    // Automatically builds: dx1/dt = v1, dv1/dt = F1/m1, etc.
    //=========================================================================

    double x1_dot() const { return v1; }
    double v1_dot() const { return F1() / m1; }
    double x2_dot() const { return v2; }
    double v2_dot() const { return F2() / m2; }

    //=========================================================================
    // ENERGY (optional diagnostics)
    //=========================================================================

    double kinetic_energy() const {
        return 0.5 * m1 * v1 * v1 + 0.5 * m2 * v2 * v2;
    }

    double potential_energy() const {
        double ext = extension();
        return 0.5 * k * ext * ext;
    }

    double total_energy() const {
        return kinetic_energy() + potential_energy();
    }
};

//=============================================================================
// FRAMEWORK CODE - What reflection would generate automatically
//=============================================================================
// With C++26 reflection, this entire section would be generated by the
// framework by inspecting TwoMassSpring at compile time.
//
// The framework would:
// 1. Find all members (x1, v1, x2, v2, m1, m2, k, c, L0)
// 2. Find all methods ending in _dot (x1_dot, v1_dot, x2_dot, v2_dot)
// 3. Match state variables to their derivatives
// 4. Generate the Simulation class below
//=============================================================================

class TwoMassSpringSimulation {
public:
    // The user's system
    TwoMassSpring sys;

    // State indices (would be generated via reflection)
    static constexpr size_t X1 = 0;
    static constexpr size_t V1 = 1;
    static constexpr size_t X2 = 2;
    static constexpr size_t V2 = 3;
    static constexpr size_t STATE_SIZE = 4;

    // State variable names (reflection would extract these)
    static constexpr std::array<const char*, 4> names = {"x1", "v1", "x2", "v2"};

    std::array<const char*, 4> state_names() const { return names; }

    // Get initial state from system's member values
    std::vector<double> initial_state() const {
        return {sys.x1, sys.v1, sys.x2, sys.v2};
    }

    // Compute derivatives by calling the _dot methods
    std::vector<double> derivatives([[maybe_unused]] double t,
                                    const std::vector<double>& state) {
        // Copy state into system (reflection would generate this mapping)
        sys.x1 = state[X1];
        sys.v1 = state[V1];
        sys.x2 = state[X2];
        sys.v2 = state[V2];

        // Call derivative methods
        return {
            sys.x1_dot(),
            sys.v1_dot(),
            sys.x2_dot(),
            sys.v2_dot()
        };
    }

    // Query computed values
    double extension() const { return sys.extension(); }
    double kinetic_energy() const { return sys.kinetic_energy(); }
    double potential_energy() const { return sys.potential_energy(); }
    double total_energy() const { return sys.total_energy(); }
};

//=============================================================================
// SIMULATION RESULT
//=============================================================================

struct Result {
    std::vector<double> time;
    std::vector<std::vector<double>> states;

    void push(double t, const std::vector<double>& s) {
        time.push_back(t);
        states.push_back(s);
    }

    size_t size() const { return time.size(); }

    // Print with headers
    void print(size_t every = 1) const {
        std::cout << std::fixed << std::setprecision(6);
        std::cout << "time\tx1\tv1\tx2\tv2\n";
        for (size_t i = 0; i < time.size(); i += every) {
            std::cout << time[i];
            for (double v : states[i]) {
                std::cout << "\t" << v;
            }
            std::cout << "\n";
        }
    }
};

//=============================================================================
// INTEGRATOR - RK4
//=============================================================================

inline Result simulate(TwoMassSpringSimulation& sim,
                       double t_end,
                       double dt = 0.001) {
    Result result;
    auto state = sim.initial_state();
    const size_t n = state.size();

    std::vector<double> k1(n), k2(n), k3(n), k4(n), temp(n);

    double t = 0.0;
    result.push(t, state);

    while (t < t_end) {
        auto d1 = sim.derivatives(t, state);
        for (size_t i = 0; i < n; i++) {
            k1[i] = d1[i];
            temp[i] = state[i] + 0.5 * dt * k1[i];
        }

        auto d2 = sim.derivatives(t + 0.5*dt, temp);
        for (size_t i = 0; i < n; i++) {
            k2[i] = d2[i];
            temp[i] = state[i] + 0.5 * dt * k2[i];
        }

        auto d3 = sim.derivatives(t + 0.5*dt, temp);
        for (size_t i = 0; i < n; i++) {
            k3[i] = d3[i];
            temp[i] = state[i] + dt * k3[i];
        }

        auto d4 = sim.derivatives(t + dt, temp);
        for (size_t i = 0; i < n; i++) {
            k4[i] = d4[i];
            state[i] += (dt / 6.0) * (k1[i] + 2*k2[i] + 2*k3[i] + k4[i]);
        }

        t += dt;
        result.push(t, state);
    }

    return result;
}

//=============================================================================
// CONVENIENCE FUNCTION - What the user actually calls
//=============================================================================

inline Result run_two_mass_spring(
    double m1 = 1.0,
    double m2 = 1.0,
    double k = 10.0,
    double c = 0.1,
    double L0 = 1.0,
    double x1_init = 0.0,
    double v1_init = 0.0,
    double x2_init = 1.5,  // Stretched from rest
    double v2_init = 0.0,
    double t_end = 10.0,
    double dt = 0.001
) {
    TwoMassSpringSimulation sim;

    // Set parameters
    sim.sys.m1 = m1;
    sim.sys.m2 = m2;
    sim.sys.k = k;
    sim.sys.c = c;
    sim.sys.L0 = L0;

    // Set initial conditions
    sim.sys.x1 = x1_init;
    sim.sys.v1 = v1_init;
    sim.sys.x2 = x2_init;
    sim.sys.v2 = v2_init;

    return simulate(sim, t_end, dt);
}

} // namespace sopot::reflect
